1. Implement a function to check if a binary tree is balanced. For the purposes of this question, a balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.
2. Given a directed graph, design an algorithm to determine if there is a route between two nodes.
3. Given a sorted (increasing order) with unique integer elements, write an algorithm to create a binary search tree with minimum height.
4. Given a binary search tree, design an algorithm which creates a linked list of all the nodes at each depth (if you have a tree of depth D then you would have D linked lists).
5. implement a function to check if a binary tree is a binary search tree.
6. Write an algorithm to find the 'next' node (i.e., in order successor) of a given node in a binary search tree. You may assume that each node has a link to its parents.
7. Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional nodes in a data structure. NOTE this is not necessarily a binary search tree.
8. You have two very large binary trees: T1, with millions of nodes, and T2, with hundreds of nodes. Create an algorithm to determine if T2 is a subtree of tree one. A tree T2 is a subtree of T1 if if there exists a node N in T1 such that the subtree of N is identical to T2. That is, if you cut off the tree at node N, the two trees would be identical.
9. You are given a binary tree in which each node contains a value. Design an algorithm to print all paths that sum to a given value. The path does not need to start or end at a root or a leaf but it must go in a straight line down.

